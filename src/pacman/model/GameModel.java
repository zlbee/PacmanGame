package pacman.model;

import javafx.animation.AnimationTimer;
import javafx.scene.Group;
import javafx.scene.Parent;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Observable;
import java.util.Random;
import java.util.Set;

/**
 * This class represents the game board that contains game objects.
 * <p>This class is a single instance that can be directly used by other classes.
 * All objects is able to be generated in specific positions of the game board.
 * Game logic is defined in this class.
 * @see pacman.controller.GameController
 * @see ActorFactory
 * @see Cookie
 * @see DoublePortals
 * @see Ghost
 * @see LevelEntry
 * @see Maze
 * @see Score
 * @see SuperCookie
 * @see ThePacman
 * @author Zhangli Wang
 *
 */
public class GameModel extends Observable {
   //create an object of GameModel
	/**
	 * {@value the only instance of GameModel} 
	 */
   private static GameModel instance = new GameModel();
   
   /**
    * Get the only object available.
    * @return the instance of GameModel
    */
   public static GameModel getInstance(){
      return instance;
   }
	
   /**
    * the only pacman on the game board
    */
	public ThePacman pacman;
	/**
	 * {@code List} of {@code Cookie} on the game board
	 */
    public List<Cookie> cookieSet;
    /**
     * The super cookie on the game board
     */
    public SuperCookie superCookie;
    /**
     * {@code Set} of {@code Ghost} on the game board
     */
    public Set<Ghost> ghosts;
    /**
     * the double portals on the game board, left portal and right portal
     */
    public DoublePortals portals;
    /**
     * the maze that contains all the obstacles on the game board
     */
    public Maze maze;
    /**
     * remaining lifes of pacman on the game board
     */
    public int lifes;
    /**
     * count of the level
     */
    public int level;
    /**
     * the score point of the pacman
     */
    public int scorePoint;
    /**
     * a score board showing {@code scorePoint} and {@code lifes} on the game board
     */
    public Score scoreBoard;
    /**
     * a boolean that indicates whether the game is ended
     */
    public boolean gameEnded;
    /**
     * a boolean that indicates whether this game is in infinite mode or not
     */
    public boolean infiniteGame;
    /**
     * a level entry on the game board
     */
    public LevelEntry levelEntry;
    /**
     * the count for all cookies eaten by the pacman
     */
    int cookiesEaten;
    /**
     * an actor factory to produce different kinds of actors, {@code ThePacman} or {@code Ghost}
     */
    private ActorFactory actorFactory = new ActorFactory();
    /**
     * a random generator
     */
    private static Random random;

    /**
     * Initialize the game with new {@code maze}, {@code portals}, {@code pacman} at the center (generated by {@code actorFactory}, {@code ghosts}
     * {@code lifes} as {@code "3"}, {@code scorePoint} as {@code "0"}, {@code cookieEaten} as {@code "0"}. 
     */
    private GameModel() {
        this.maze = new Maze();
        this.portals = new DoublePortals();
        this.pacman = (ThePacman) actorFactory.getActor("PACMAN", 24.5 * BarObstacle.THICKNESS, 12.5 * BarObstacle.THICKNESS, this);
        this.cookieSet = new ArrayList<>();
        this.ghosts = new HashSet<>();
        this.lifes = 3;
        this.scorePoint = 0;
        this.level = 1;
        this.cookiesEaten = 0;
        this.scoreBoard = new Score();
    }
    
    /*
     * on development
    void removeGhost(Ghost ghost) {
    	int removedGhostId = ghost.ghostId;
    	this.ghosts.remove(ghost);
    	this.setChanged();
    	this.notifyObservers("5");
    }
    */

    /**
     * Minus {@code lifes} in this class by one and reset other properties in this class.
     * <p>Stop animation of all ghosts, reset position of the pacman
     * , minus life and score and notify {@code GameController} to make corresponding response to the view. 
     * If life is equal to {@code "0"}, call {@code endGame}.
     */
    void lifeLost() {
        for (Ghost ghost : ghosts) {
            ghost.getAnimation().stop();
        }
        this.pacman.setCenterX(24.5 * BarObstacle.THICKNESS);
        this.pacman.setCenterY(12.5 * BarObstacle.THICKNESS);
        lifes--;
        scorePoint -= 10;
        if (lifes == 0) {
            this.endGame();
        }
        this.setChanged();
        this.notifyObservers("1");
    }

    /**
     * Ends the game and reset values in this class.
     * <p>Reset {@code ghostId} to one and set {@code gameEnded} to true.
     * Notify {@code GameController} to make game ending response to view.
     */
    public void endGame() {
        this.scoreBoard.lifes.setText("Lifes: 0");
    	Ghost.ghostId = 1;
        this.gameEnded = true;
        this.setChanged();
		this.notifyObservers("2"); 
    }
    
    /**
     * Adopted in infinite mode, show the game entry.
     * <p>Set {@code clearLevel} as {@code isVisible}.
     * Notify {@code GameController} to make corresponding response to view. 
     */
    public void clearLevel() {
    	this.levelEntry.show();
        this.setChanged();
		this.notifyObservers("3"); 
    }
    
    // enter next level
    /**
     * Adopted in infinite mode, change some properties of this class when pacman has entered next level.
     * <p>Reset game setting except the {@code Score} and {@code Lifes}
     * Refresh {@code scoreBoard} as current {@code Score} and {@code Lifes}.
     * Slightly increase speed of ghost in the next level.
     * Notify {@code GameController} to make corresponding response to view.
     */
    public void enterNextLevel() {
        this.level++;
        this.scoreBoard.lifes.setText("Lifes: " + this.lifes);
        this.scoreBoard.score.setText("Score: " + this.scorePoint);
        this.scoreBoard.level.setText("Level: " + this.level);
        this.cookieSet.clear();
        this.ghosts.clear();
        this.pacman.setCenterX(24.5 * BarObstacle.THICKNESS);
        this.pacman.setCenterY(12.5 * BarObstacle.THICKNESS);
        ThePacman.pacmanStep = 5;
        this.cookiesEaten = 0;
        
        Ghost.ghostId = 1;
        if (Ghost.ghostStep < 7.5) {
        	Ghost.ghostStep = Ghost.ghostStep+0.5;
        }
        
        this.setChanged();
        this.notifyObservers("4");
    }

    /**
     * Reset the game setting.
     * <p>Clear {@code cookieSet} and {@code ghosts}.
     * Reset {@code Pacman} and {@code Ghost} static properties.
     * Reset {@code lifes} and other records of the game.
     */
    public void restartGame() {
        this.cookieSet.clear();
        this.ghosts.clear();
        this.pacman.setCenterX(24.5 * BarObstacle.THICKNESS);
        this.pacman.setCenterY(12.5 * BarObstacle.THICKNESS);
        ThePacman.pacmanStep = 5;
        Ghost.ghostStep = 5;
        Ghost.ghostId = 1;
        this.lifes = 3;
        this.scorePoint = 0;
        this.level = 1;
        this.scoreBoard.lifes.setText("Lifes: " + this.lifes);
        this.scoreBoard.score.setText("Score: " + this.scorePoint);
        this.scoreBoard.level.setText("Level: " + this.level);

        this.cookiesEaten = 0;
        gameEnded = false;
    }
    
    /**
     * Initialize game components, including the maze and all game items.
     */
    public void initGame() {
        this.maze.CreateMaze();
        
        this.generateGhosts();
        
        this.generateCookies();
        
        this.generatePortals();
        
        this.generateLevelEntry();
        
        //this.scoreBoard = new Score();
    }

    /**
     * Generates four ghosts and add them to {@code ghosts}, two positioned on the left top side of the game board 
     * and two positioned at the right top side of the game board.
     */
    public void generateGhosts() {
    	this.ghosts.add((Ghost) actorFactory.getActor("GHOST", 1.5 * BarObstacle.THICKNESS, 1.5 * BarObstacle.THICKNESS, this));
    	this.ghosts.add((Ghost) actorFactory.getActor("GHOST", 1.5 * BarObstacle.THICKNESS, 1.5 * BarObstacle.THICKNESS, this));
    	this.ghosts.add((Ghost) actorFactory.getActor("GHOST", 45.5 * BarObstacle.THICKNESS, 1.5 * BarObstacle.THICKNESS, this));
    	this.ghosts.add((Ghost) actorFactory.getActor("GHOST", 45.5 * BarObstacle.THICKNESS, 1.5 * BarObstacle.THICKNESS, this));
    }
    
    /**
     * Generates cookies on all the paths except the safe house (center block). 
     * One of the cookies is replaced with a super cookie.
     */
    public void generateCookies() {
    	// 1st line
        Integer skip[] = {5, 17};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2*i) + 2.5) * BarObstacle.THICKNESS, 2.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 2nd line
        skip = new Integer[]{1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 19, 20, 21};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2*i) + 2.5) * BarObstacle.THICKNESS, 4.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 3rd line
        skip = new Integer[]{1, 21};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2*i) + 2.5) * BarObstacle.THICKNESS, 6.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 4th line
        skip = new Integer[]{1, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 21};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2 * i) + 2.5) * BarObstacle.THICKNESS, 8.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 5th line
        skip = new Integer[]{1, 7, 8, 9, 10, 11, 12, 13, 14, 15, 21};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2*i) + 2.5) * BarObstacle.THICKNESS, 10.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 6th line
        skip = new Integer[]{3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2*i) + 2.5) * BarObstacle.THICKNESS, 12.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 7th line
        skip = new Integer[]{1, 7, 8, 9, 10, 11, 12, 13, 14, 15, 21};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2 * i) + 2.5) * BarObstacle.THICKNESS, 14.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 8th line
        skip = new Integer[]{1, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 21};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2 * i) + 2.5) * BarObstacle.THICKNESS, 16.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 9th line
        skip = new Integer[]{1, 21};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2 * i) + 2.5) * BarObstacle.THICKNESS, 18.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 10th line
        skip = new Integer[]{1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 19, 20, 21};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2*i) + 2.5) * BarObstacle.THICKNESS, 20.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }

        // 11th line, first cookie is super cookie
        skip = new Integer[]{5, 17};
        for (int i = 0; i < 23; i++) {
            if (!Arrays.asList(skip).contains(i)) {
                Cookie cookie = new Cookie(((2 * i) + 2.5) * BarObstacle.THICKNESS, 22.5 * BarObstacle.THICKNESS);
                this.cookieSet.add(cookie);
            }
        }
        
        // replace one of the cookies with a super cookie
        int randIndex = getRandomInt(cookieSet.size());
    	Cookie superCookie = new SuperCookie(cookieSet.get(randIndex).getCenterX(), cookieSet.get(randIndex).getCenterY());
        cookieSet.remove(randIndex);
    	this.cookieSet.add(superCookie);
        
    }
    
    /**
     * Generate portals, left portal is on the left gap of the game board
     * and right portal is on the right gap of the game board.
     */
    public void generatePortals() {
    	portals.leftPortal = new Portal(0, 275, "vertical", 3);
    	portals.rightPortal = new Portal(1225, 275, "vertical", 3);
    }
    
    /**
     * Generate level entry on the right bottom side of the game board.
     */
    public void generateLevelEntry() {
    	levelEntry = new LevelEntry(46 * BarObstacle.THICKNESS, 22 * BarObstacle.THICKNESS);
    }
    
    /**
     * Generate an {@code int} value within [0, {@code max}).
     * @param max - the max possible value
     * @return an {@code int} value within [0, {@code max})
     */
    //https://www.cnblogs.com/winkey4986/p/7592094.html
    private int getRandomInt(int max) {
        return Math.abs(getRandom().nextInt()) % max;
    }
    
    /**
     * Get a random single instance.
     * @return the random instance
     */
    // https://www.cnblogs.com/winkey4986/p/7592094.html
    private Random getRandom() {
        if(random == null){
            synchronized (GameModel.class) {
                if(random == null){
                    random = new Random();
                }
            }
        }
        return random;
    } 
}
